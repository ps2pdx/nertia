<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Battlezone Complete</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; color: #00ff00; font-family: monospace; font-size: 14px; }
    #hud { position: absolute; top: 0; width: 100%; text-align: center; color: #00ff00; background: rgba(0, 0, 0, 0.8); padding: 5px; z-index: 10; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="hud">Score: <span id="score">0</span></div>
  <script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.150.1';

    let scene, camera, renderer;
    let tank, tankBody;
    let moveForward = false;
    let moveBackward = false;
    let turnLeft = false;
    let turnRight = false;
    const speed = 0.1;
    const turnSpeed = 0.03;

    const bounds = 50; // world size limit

    let missiles = [];
    const missileSpeed = 0.3;
    const missileLifetime = 100;

    let enemies = [];
    let explosions = [];
    const enemySpeed = 0.02;
    let score = 0;
    const scoreDisplay = document.getElementById("score");

    // Sound effects
    const fireSound = new Audio('fire.mp3');
    const explosionSound = new Audio('boom.mp3');

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const geometry = new THREE.BoxGeometry(1, 1, 2);
      const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
      tankBody = new THREE.Mesh(geometry, material);

      tank = new THREE.Object3D();
      tank.add(tankBody);
      scene.add(tank);

      camera.position.set(0, 1, 0);
      camera.lookAt(new THREE.Vector3(0, 1, 1));
      tank.add(camera);

      const gridHelper = new THREE.GridHelper(100, 100, 0x00ff00, 0x00ff00);
      scene.add(gridHelper);

      for (let i = 0; i < 5; i++) spawnEnemy();
      setInterval(spawnEnemy, 5000);

      window.addEventListener('resize', onWindowResize);
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
    }

    function spawnEnemy() {
      const geometry = new THREE.BoxGeometry(1, 1, 2);
      const material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
      const enemy = new THREE.Mesh(geometry, material);
      enemy.position.set(Math.random() * 80 - 40, 0, Math.random() * 80 - 40);
      enemy.rotation.y = Math.random() * Math.PI * 2;
      scene.add(enemy);
      enemies.push(enemy);
    }

    function fireMissile() {
      const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
      const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
      const missile = new THREE.Mesh(geometry, material);
      missile.position.set(0, 0.2, 1);
      missile.quaternion.copy(tank.quaternion);
      tank.localToWorld(missile.position);
      scene.add(missile);
      missiles.push({ mesh: missile, life: missileLifetime });
      fireSound.currentTime = 0;
      fireSound.play();
    }

    function explodeAt(position) {
      const geometry = new THREE.SphereGeometry(0.5, 8, 8);
      const material = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
      const explosion = new THREE.Mesh(geometry, material);
      explosion.position.copy(position);
      scene.add(explosion);
      explosions.push({ mesh: explosion, life: 20 });
      explosionSound.currentTime = 0;
      explosionSound.play();
    }

    function onKeyDown(event) {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW': moveForward = true; break;
        case 'ArrowDown':
        case 'KeyS': moveBackward = true; break;
        case 'ArrowLeft':
        case 'KeyA': turnLeft = true; break;
        case 'ArrowRight':
        case 'KeyD': turnRight = true; break;
        case 'Space': fireMissile(); break;
      }
    }

    function onKeyUp(event) {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW': moveForward = false; break;
        case 'ArrowDown':
        case 'KeyS': moveBackward = false; break;
        case 'ArrowLeft':
        case 'KeyA': turnLeft = false; break;
        case 'ArrowRight':
        case 'KeyD': turnRight = false; break;
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function clampToBounds(object) {
      const x = THREE.MathUtils.clamp(object.position.x, -bounds, bounds);
      const z = THREE.MathUtils.clamp(object.position.z, -bounds, bounds);
      object.position.set(x, object.position.y, z);
    }

    function animate() {
      requestAnimationFrame(animate);

      if (moveForward) tank.translateZ(-speed);
      if (moveBackward) tank.translateZ(speed);
      if (turnLeft) tank.rotation.y += turnSpeed;
      if (turnRight) tank.rotation.y -= turnSpeed;

      clampToBounds(tank);

      missiles.forEach((m, mIndex) => {
        m.mesh.translateZ(missileSpeed);
        m.life--;
        enemies.forEach((e, eIndex) => {
          if (m.mesh.position.distanceTo(e.position) < 1) {
            explodeAt(e.position);
            scene.remove(e);
            enemies.splice(eIndex, 1);
            scene.remove(m.mesh);
            missiles.splice(mIndex, 1);
            score++;
            scoreDisplay.textContent = score;
          }
        });
        if (m.life <= 0 && m.mesh.parent) {
          scene.remove(m.mesh);
          missiles.splice(mIndex, 1);
        }
      });

      enemies.forEach(enemy => {
        enemy.translateZ(enemySpeed);
        if (Math.random() < 0.01) enemy.rotation.y += (Math.random() - 0.5) * 0.2;
        clampToBounds(enemy);
      });

      explosions.forEach((ex, index) => {
        ex.life--;
        ex.mesh.scale.multiplyScalar(1.05);
        if (ex.life <= 0) {
          scene.remove(ex.mesh);
          explosions.splice(index, 1);
        }
      });

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
